# 2. 시스템 설계

## 🏗️ 전체 아키텍처 개요

### 설계 원칙

#### 1. **컨텍스트 중심 설계**

```
모든 것은 "현재 무엇을 하고 있는가?"를 중심으로 설계
- 현재 단계 (탐색/계획/구현/커밋)
- 현재 기능 (JWT 인증, 북마크 CRUD 등)
- 현재 상태 (진행중/완료/대기)
```

#### 2. **점진적 복잡성**

```
단순한 것부터 시작해서 필요에 따라 확장
- 최소: 기본 4단계 워크플로우
- 표준: 자동화 추가
- 고급: 커스텀 Hook과 통합
```

#### 3. **자연스러운 통합**

```
기존 개발 워크플로우를 크게 바꾸지 않음
- Git 워크플로우와 호환
- 기존 폴더 구조 유지
- 추가 도구 설치 불필요
```

## 📁 폴더 구조 설계

### 전체 구조

```
project-root/
├── context/                    # 컨텍스트 관리 폴더
│   ├── README.md              # 시스템 사용법
│   ├── current-status.md      # 현재 상태 대시보드
│   ├── workflow/              # 워크플로우별 컨텍스트
│   │   ├── exploration.md     # 탐색 단계
│   │   ├── planning.md        # 계획 단계
│   │   ├── implementation.md  # 구현 단계
│   │   └── commit.md          # 커밋 단계
│   ├── features/              # 기능별 컨텍스트
│   │   ├── template.md        # 기능 템플릿
│   │   ├── auth-system.md     # 인증 시스템
│   │   └── bookmark-crud.md   # 북마크 CRUD
│   └── history/               # 완료된 작업 히스토리
│       ├── template.md        # 히스토리 템플릿
│       └── 2025-07-19-auth.md # 완료된 기능 기록
├── .claude/                   # 자동화 설정
│   └── hooks/                 # Hook 파일들
│       ├── README.md          # Hook 시스템 설명
│       ├── context-auto-update.md
│       ├── pre-commit-checklist.md
│       ├── post-commit-cleanup.md
│       └── stage-transition.md
└── [기존 프로젝트 파일들]
```

### 각 폴더의 역할과 설계 이유

#### **context/ 폴더**

```
역할: 모든 개발 컨텍스트의 중앙 집중 관리
설계 이유:
- 한 곳에서 모든 정보 접근 가능
- Git으로 버전 관리 가능
- 텍스트 파일로 검색 용이
- 백업과 공유 간편
```

#### **workflow/ 서브폴더**

```
역할: 4단계 워크플로우별 상태 관리
설계 이유:
- 각 단계별로 다른 정보 필요
- 단계 전환 시 명확한 체크포인트 제공
- 현재 위치 파악 용이
```

#### **features/ 서브폴더**

```
역할: 기능별 개발 히스토리 관리
설계 이유:
- 기능 단위 추적 가능
- 기능 간 의존성 파악 용이
- 완료 후 참조 자료로 활용
```

#### **history/ 서브폴더**

```
역할: 완료된 작업의 아카이브
설계 이유:
- 진행 중/완료 구분으로 혼란 방지
- 성과 추적과 학습 자료로 활용
- 프로젝트 전체 진행 상황 파악
```

## 🔄 4단계 워크플로우 설계

### 단계별 목적과 산출물

#### **1. 탐색 (Exploration) 단계**

```
목적: 문제 이해와 현황 파악
주요 활동:
- 기존 코드 분석
- 관련 라이브러리 조사
- 유사 구현 사례 연구
- 기술적 제약사항 파악

산출물:
- 현황 분석 결과
- 필요한 기술/라이브러리 목록
- 예상 영향 범위
- 잠재적 이슈 목록

다음 단계 조건:
- 충분한 정보 수집 완료
- 구현 방향성 결정
```

#### **2. 계획 (Planning) 단계**

```
목적: 구체적인 구현 방법 설계
주요 활동:
- 아키텍처 설계
- API 엔드포인트 정의
- 데이터 구조 설계
- 테스트 계획 수립

산출물:
- 상세 설계 문서
- 구현할 파일 목록
- 테스트 시나리오
- 예상 일정

다음 단계 조건:
- 모든 설계 완료
- 구현 순서 확정
```

#### **3. 구현 (Implementation) 단계**

```
목적: 실제 코드 작성과 테스트
주요 활동:
- 코드 작성
- 단위 테스트 작성
- 통합 테스트 수행
- 문제 해결

산출물:
- 구현된 코드
- 테스트 코드
- 발생한 이슈와 해결책
- 성능/품질 검증 결과

다음 단계 조건:
- 모든 기능 구현 완료
- 테스트 통과
- 코드 리뷰 준비 완료
```

#### **4. 커밋 (Commit) 단계**

```
목적: 품질 검증과 코드 통합
주요 활동:
- 최종 코드 리뷰
- 보안 검사
- 성능 검증
- 문서 업데이트

산출물:
- 검증된 커밋
- 업데이트된 문서
- 완료 보고서
- 다음 작업 준비

완료 조건:
- 모든 체크리스트 통과
- 품질 기준 만족
- 문서화 완료
```

### 단계 간 전환 조건

```
탐색 → 계획:
✅ 충분한 정보 수집
✅ 기술적 방향성 결정
✅ 주요 제약사항 파악

계획 → 구현:
✅ 상세 설계 완료
✅ 구현 방법 확정
✅ 테스트 계획 수립

구현 → 커밋:
✅ 모든 기능 구현
✅ 테스트 통과
✅ 기본 품질 검사 통과

커밋 → 완료:
✅ 최종 검증 완료
✅ 문서 업데이트
✅ 다음 작업 준비
```

## 🤖 자동화 시스템 설계

### Hook 기반 자동화 아키텍처

```
사용자 입력 → 키워드 감지 → Hook 실행 → 컨텍스트 업데이트
    ↑                                              ↓
    ←── 피드백과 가이드 제공 ←── 상태 분석 ←──
```

### Hook 타입별 설계

#### **1. Context Auto-Update Hook**

```
트리거: 파일 변경 감지
역할: 변경된 파일을 분석하여 관련 컨텍스트 자동 업데이트
설계 이유: 수동 업데이트 부담 제거

작동 방식:
1. 변경된 파일 경로 분석
2. 파일-기능 매핑 테이블 참조
3. 해당 기능의 컨텍스트 파일 업데이트
4. 진행률 자동 갱신
```

#### **2. Stage Transition Hook**

```
트리거: "단계: [단계명]" 키워드 감지
역할: 워크플로우 단계 전환 시 필요한 작업 자동화
설계 이유: 단계별 일관된 프로세스 보장

작동 방식:
1. 현재 단계 검증
2. 이전 단계 완료 여부 확인
3. 새 단계 환경 준비
4. 해당 단계 체크리스트 제공
```

#### **3. Pre-Commit Checklist Hook**

```
트리거: "커밋해줘" 키워드 감지
역할: 커밋 전 품질 검사 자동 실행
설계 이유: 휴먼 에러 방지와 품질 보장

작동 방식:
1. 코드 품질 자동 검사
2. 보안 이슈 스캔
3. 테스트 실행 확인
4. 문서 동기화 검증
5. 통과 시에만 커밋 진행
```

#### **4. Post-Commit Cleanup Hook**

```
트리거: 커밋 완료 감지
역할: 커밋 후 정리 작업 자동화
설계 이유: 완료 처리와 다음 작업 준비 자동화

작동 방식:
1. 완료된 기능을 history로 이동
2. 워크플로우 파일 초기화
3. 진행률 업데이트
4. 다음 기능 제안
```

### 자동화 안전장치

#### **무한 루프 방지**

```
문제: Hook이 다른 Hook을 트리거하는 순환 참조
해결: 실행 컨텍스트 추적과 최대 depth 제한
```

#### **실행 실패 처리**

```
문제: Hook 실행 중 오류 발생
해결: 상태 롤백과 수동 모드 전환
```

#### **사용자 제어권 보장**

```
원칙: 자동화는 제안, 최종 결정은 사용자
구현: 중요한 변경 전 확인 요청
```

## 📋 데이터 모델 설계

### 상태 정보 구조

#### **현재 상태 (current-status.md)**

```yaml
current_feature: "JWT 인증 시스템"
current_stage: "구현" # 탐색/계획/구현/커밋
progress:
  phase1: 60%
  current_feature: 75%
last_updated: "2025-07-19T10:30:00Z"
next_actions:
  - "토큰 검증 미들웨어 구현"
  - "리프레시 토큰 로직 추가"
```

#### **기능별 컨텍스트 (features/[기능명].md)**

```yaml
feature_name: "JWT 인증 시스템"
priority: "high"
start_date: "2025-07-19"
current_stage: "구현"
completion: 75%
files_changed:
  - "src/auth/jwt.service.ts"
  - "src/middleware/auth.middleware.ts"
issues_encountered:
  - type: "라이브러리 호환성"
    status: "해결됨"
    solution: "jsonwebtoken 8.5.1 사용"
```

### 템플릿 시스템

#### **일관성 보장을 위한 템플릿 구조**

```
모든 컨텍스트 파일은 표준 템플릿 기반:
- 메타데이터 섹션 (YAML frontmatter)
- 표준 섹션 구조
- 체크리스트 형식 통일
- 상태 표시 표준화 (✅/❌/🔄/⏳)
```

## 🔗 통합 설계

### Git 워크플로우와의 통합

```
기존 Git 워크플로우:
feature branch → 개발 → commit → merge

확장된 워크플로우:
feature branch → 탐색 → 계획 → 구현 → 품질검사 → commit → 정리 → merge
                   ↑_____________컨텍스트 관리 범위_____________↑
```

### IDE/에디터와의 호환성

```
설계 원칙: 특정 도구에 종속되지 않음
- 모든 파일이 Markdown → 어떤 에디터에서든 편집 가능
- 표준 폴더 구조 → IDE의 파일 탐색기로 접근 가능
- Git 연동 → 기존 Git 도구 그대로 사용 가능
```

## 📊 확장성 고려사항

### 팀 프로젝트로의 확장

```
개인 → 팀 확장 시 고려사항:
- 개인별 컨텍스트 분리
- 팀 공통 컨텍스트 관리
- 권한과 접근 제어
- 컨텍스트 병합 정책
```

### 다른 도구로의 포팅

```
Claude Code Hook → 다른 도구 Hook
- GitHub Actions로 서버 사이드 자동화
- VS Code Extension으로 에디터 통합
- Slack Bot으로 팀 알림 연동
```

---

**다음 문서**: [3. Claude Code Hook 자동화](03-automation-with-hooks.md)
